// filedb.go
package main

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/gofrs/flock"
)

// Record is an example record. First field (ID) is numeric and unique.
type Record struct {
	ID    int64
	Name  string
	Email string
}

// DB is a small file-backed DB using delimited text format.
// Each line is a record. Fields are ID,Name,Email separated by delimiter.
type DB struct {
	path      string
	delim     rune // single rune delimiter (we enforce this)
	mu        sync.RWMutex
	nextID    int64
	perm      os.FileMode
	loadedMax bool

	fileLock *flock.Flock // cross-process file lock
}

// NewDB returns a DB instance. It loads the existing file to initialize nextID.
func NewDB(path string, delim string) (*DB, error) {
	if delim == "" {
		delim = "|"
	}
	// enforce single rune delimiter
	drunes := []rune(delim)
	if len(drunes) != 1 {
		return nil, errors.New("delimiter must be a single rune/character")
	}
	db := &DB{
		path:     path,
		delim:    drunes[0],
		perm:     0644,
		fileLock: flock.New(path + ".lock"),
	}

	// Acquire exclusive lock during initial scan to avoid races with other processes initializing concurrently.
	if err := db.fileLock.Lock(); err != nil {
		return nil, fmt.Errorf("locking failed during NewDB: %w", err)
	}
	// We want to release before returning, after loadMaxID completes.
	defer func() {
		_ = db.fileLock.Unlock()
	}()

	if err := db.loadMaxID(); err != nil {
		return nil, err
	}
	return db, nil
}

// loadMaxID scans the file to set nextID (max existing ID + 1).
// Caller MUST hold the fileLock if concurrently used across processes (NewDB does).
func (db *DB) loadMaxID() error {
	db.mu.Lock()
	defer db.mu.Unlock()

	file, err := os.Open(db.path)
	if err != nil {
		if os.IsNotExist(err) {
			db.nextID = 1
			db.loadedMax = true
			return nil
		}
		return err
	}
	defer file.Close()

	reader := bufio.NewReader(file)
	var max int64 = 0
	lineNo := 0
	for {
		line, err := reader.ReadString('\n')
		if err != nil && err != io.EOF {
			return err
		}
		lineNo++
		trim := strings.TrimRight(line, "\n")
		if strings.TrimSpace(trim) != "" {
			rec, perr := db.parseLine(trim)
			if perr != nil {
				log.Printf("loadMaxID: malformed line %d: %v (preserved)\n", lineNo, perr)
			} else {
				if rec.ID > max {
					max = rec.ID
				}
			}
		}
		if err == io.EOF {
			break
		}
	}
	db.nextID = max + 1
	db.loadedMax = true
	return nil
}

// helper to format a record to a single line with escaping
func (db *DB) formatLine(r *Record) string {
	// Escape fields (backslash-escape both backslash and delimiter)
	return fmt.Sprintf("%d%s%s%s%s\n",
		r.ID,
		string(db.delim),
		escapeField(r.Name, db.delim),
		string(db.delim),
		escapeField(r.Email, db.delim),
	)
}

// parseLine -> Record
func (db *DB) parseLine(line string) (*Record, error) {
	parts, err := splitEscaped(line, db.delim)
	if err != nil {
		return nil, err
	}
	if len(parts) < 3 {
		return nil, errors.New("malformed record (not enough fields)")
	}
	id, err := strconv.ParseInt(strings.TrimSpace(parts[0]), 10, 64)
	if err != nil {
		return nil, err
	}
	name, err := unescapeField(parts[1], db.delim)
	if err != nil {
		return nil, err
	}
	email, err := unescapeField(parts[2], db.delim)
	if err != nil {
		return nil, err
	}
	return &Record{
		ID:    id,
		Name:  name,
		Email: email,
	}, nil
}

// escapeField replaces backslash with \\ and delim with \delim
func escapeField(s string, delim rune) string {
	var b strings.Builder
	for _, r := range s {
		if r == '\\' {
			b.WriteRune('\\')
			b.WriteRune('\\')
		} else if r == delim {
			b.WriteRune('\\')
			b.WriteRune(delim)
		} else {
			b.WriteRune(r)
		}
	}
	return b.String()
}

// unescapeField reverses escapeField, treating unknown escape sequences as literal backslash + char.
func unescapeField(s string, delim rune) (string, error) {
	var b strings.Builder
	esc := false
	for _, r := range s {
		if esc {
			// accept either delim or backslash after escape
			if r == delim || r == '\\' {
				b.WriteRune(r)
				esc = false
				continue
			}
			// unknown escape -> treat as literal backslash + char
			b.WriteRune('\\')
			b.WriteRune(r)
			esc = false
			continue
		}
		if r == '\\' {
			esc = true
			continue
		}
		b.WriteRune(r)
	}
	if esc {
		// trailing backslash â€” treat as literal backslash
		b.WriteRune('\\')
	}
	return b.String(), nil
}

// splitEscaped splits a line on delim rune but respects backslash-escaping.
// Unknown escape sequences retain the backslash.
func splitEscaped(line string, delim rune) ([]string, error) {
	var parts []string
	var b strings.Builder
	esc := false
	for _, r := range line {
		if esc {
			// write literal backslash then char for unknown escapes;
			// if it's delim or backslash, we only write the char (as it was escaped)
			if r == delim || r == '\\' {
				b.WriteRune(r)
			} else {
				b.WriteRune('\\')
				b.WriteRune(r)
			}
			esc = false
			continue
		}
		if r == '\\' {
			esc = true
			continue
		}
		if r == delim {
			parts = append(parts, b.String())
			b.Reset()
			continue
		}
		b.WriteRune(r)
	}
	// append whatever is left
	parts = append(parts, b.String())
	return parts, nil
}

// Create appends a new record, returns the created Record with ID populated.
func (db *DB) Create(name, email string) (*Record, error) {
	// Acquire cross-process exclusive lock for writes (serialize creates across processes).
	if err := db.fileLock.Lock(); err != nil {
		return nil, fmt.Errorf("create: failed to lock: %w", err)
	}
	defer func() {
		_ = db.fileLock.Unlock()
	}()

	db.mu.Lock()
	defer db.mu.Unlock()

	// ensure nextID initialized
	if !db.loadedMax {
		if err := db.loadMaxID(); err != nil {
			return nil, err
		}
	}

	// assign ID
	id := db.nextID
	db.nextID++

	rec := &Record{ID: id, Name: name, Email: email}

	// open file in append mode with buffered writer
	f, err := os.OpenFile(db.path, os.O_WRONLY|os.O_CREATE|os.O_APPEND, db.perm)
	if err != nil {
		return nil, err
	}
	// ensure file closed
	defer f.Close()

	w := bufio.NewWriter(f)
	if _, err := w.WriteString(db.formatLine(rec)); err != nil {
		return nil, err
	}
	if err := w.Flush(); err != nil {
		return nil, err
	}
	// attempt to sync to disk
	if err := f.Sync(); err != nil {
		// non-fatal: log warning and return created record
		log.Printf("warning: create wrote but fsync failed: %v\n", err)
	}
	return rec, nil
}

// ReadAll returns all records.
func (db *DB) ReadAll() ([]*Record, error) {
	// Acquire file lock to prevent reading while an atomic rewrite is in progress.
	// We use exclusive lock here for correctness; if you need concurrency, switch to a shared/exclusive scheme.
	if err := db.fileLock.Lock(); err != nil {
		return nil, fmt.Errorf("readall: failed to lock: %w", err)
	}
	defer func() {
		_ = db.fileLock.Unlock()
	}()

	db.mu.RLock()
	defer db.mu.RUnlock()

	f, err := os.Open(db.path)
	if err != nil {
		if os.IsNotExist(err) {
			return []*Record{}, nil
		}
		return nil, err
	}
	defer f.Close()

	var res []*Record
	r := bufio.NewReader(f)
	lineNo := 0
	for {
		line, err := r.ReadString('\n')
		if err != nil && err != io.EOF {
			return nil, err
		}
		lineNo++
		trim := strings.TrimRight(line, "\n")
		if strings.TrimSpace(trim) != "" {
			rec, parseErr := db.parseLine(trim)
			if parseErr == nil {
				res = append(res, rec)
			} else {
				// preserve line but log parse problem
				log.Printf("ReadAll: malformed line %d: %v (preserved)\n", lineNo, parseErr)
			}
		}
		if err == io.EOF {
			break
		}
	}
	return res, nil
}

// FindByID returns one record or nil if not found.
func (db *DB) FindByID(id int64) (*Record, error) {
	// Acquire lock for reading to avoid races with writers.
	if err := db.fileLock.Lock(); err != nil {
		return nil, fmt.Errorf("findbyid: failed to lock: %w", err)
	}
	defer func() {
		_ = db.fileLock.Unlock()
	}()

	db.mu.RLock()
	defer db.mu.RUnlock()

	f, err := os.Open(db.path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, err
	}
	defer f.Close()

	r := bufio.NewReader(f)
	lineNo := 0
	for {
		line, err := r.ReadString('\n')
		if err != nil && err != io.EOF {
			return nil, err
		}
		lineNo++
		trim := strings.TrimRight(line, "\n")
		if strings.TrimSpace(trim) != "" {
			rec, perr := db.parseLine(trim)
			if perr == nil && rec.ID == id {
				return rec, nil
			}
		}
		if err == io.EOF {
			break
		}
	}
	return nil, nil
}

// Update replaces the record with the same ID. Returns the updated record or error if not found.
func (db *DB) Update(id int64, name, email string) (*Record, error) {
	// lock across processes
	if err := db.fileLock.Lock(); err != nil {
		return nil, fmt.Errorf("update: failed to lock: %w", err)
	}
	defer func() {
		_ = db.fileLock.Unlock()
	}()

	db.mu.Lock()
	defer db.mu.Unlock()

	// open original
	src, err := os.Open(db.path)
	if err != nil {
		return nil, err
	}
	defer src.Close()

	dir := filepath.Dir(db.path)
	tmp, err := os.CreateTemp(dir, "dbtmp-")
	if err != nil {
		return nil, err
	}
	tmpName := tmp.Name()
	writer := bufio.NewWriter(tmp)

	found := false
	reader := bufio.NewReader(src)
	lineNo := 0
	for {
		line, err := reader.ReadString('\n')
		if err != nil && err != io.EOF {
			tmp.Close()
			_ = os.Remove(tmpName)
			return nil, err
		}
		lineNo++
		trim := strings.TrimRight(line, "\n")
		if strings.TrimSpace(trim) != "" {
			rec, perr := db.parseLine(trim)
			if perr != nil {
				// copy malformed line as-is (preserve)
				if _, err := writer.WriteString(trim + "\n"); err != nil {
					tmp.Close()
					_ = os.Remove(tmpName)
					return nil, err
				}
			} else {
				if rec.ID == id {
					updated := &Record{ID: id, Name: name, Email: email}
					if _, err := writer.WriteString(db.formatLine(updated)); err != nil {
						tmp.Close()
						_ = os.Remove(tmpName)
						return nil, err
					}
					found = true
				} else {
					if _, err := writer.WriteString(db.formatLine(rec)); err != nil {
						tmp.Close()
						_ = os.Remove(tmpName)
						return nil, err
					}
				}
			}
		} else {
			// preserve empty lines
			if _, err := writer.WriteString("\n"); err != nil {
				tmp.Close()
				_ = os.Remove(tmpName)
				return nil, err
			}
		}
		if err == io.EOF {
			break
		}
	}
	if err := writer.Flush(); err != nil {
		tmp.Close()
		_ = os.Remove(tmpName)
		return nil, err
	}
	// sync & close tmp
	if err := tmp.Sync(); err != nil {
		log.Printf("warning: tmp file sync failed: %v\n", err)
	}
	if err := tmp.Close(); err != nil {
		_ = os.Remove(tmpName)
		return nil, err
	}
	if !found {
		_ = os.Remove(tmpName)
		return nil, fmt.Errorf("record %d not found", id)
	}
	// atomic replace
	if err := os.Rename(tmpName, db.path); err != nil {
		_ = os.Remove(tmpName)
		return nil, err
	}
	// open new file and fsync it to make rename durable
	if f, err := os.OpenFile(db.path, os.O_RDONLY, 0); err == nil {
		_ = f.Sync()
		_ = f.Close()
	}
	// fsync the directory to make rename durable
	if d, err := os.Open(dir); err == nil {
		_ = d.Sync()
		_ = d.Close()
	}
	return &Record{ID: id, Name: name, Email: email}, nil
}

// Delete removes a record by ID. Returns true if deleted.
func (db *DB) Delete(id int64) (bool, error) {
	// lock across processes
	if err := db.fileLock.Lock(); err != nil {
		return false, fmt.Errorf("delete: failed to lock: %w", err)
	}
	defer func() {
		_ = db.fileLock.Unlock()
	}()

	db.mu.Lock()
	defer db.mu.Unlock()

	src, err := os.Open(db.path)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, err
	}
	defer src.Close()

	dir := filepath.Dir(db.path)
	tmp, err := os.CreateTemp(dir, "dbtmp-")
	if err != nil {
		return false, err
	}
	tmpName := tmp.Name()
	writer := bufio.NewWriter(tmp)

	deleted := false
	reader := bufio.NewReader(src)
	for {
		line, err := reader.ReadString('\n')
		if err != nil && err != io.EOF {
			tmp.Close()
			_ = os.Remove(tmpName)
			return false, err
		}
		trim := strings.TrimRight(line, "\n")
		if strings.TrimSpace(trim) != "" {
			rec, perr := db.parseLine(trim)
			if perr != nil {
				// copy as-is
				if _, err := writer.WriteString(trim + "\n"); err != nil {
					tmp.Close()
					_ = os.Remove(tmpName)
					return false, err
				}
			} else {
				if rec.ID == id {
					deleted = true
					// skip writing this record
				} else {
					if _, err := writer.WriteString(db.formatLine(rec)); err != nil {
						tmp.Close()
						_ = os.Remove(tmpName)
						return false, err
					}
				}
			}
		} else {
			// preserve blank line
			if _, err := writer.WriteString("\n"); err != nil {
				tmp.Close()
				_ = os.Remove(tmpName)
				return false, err
			}
		}
		if err == io.EOF {
			break
		}
	}
	if err := writer.Flush(); err != nil {
		tmp.Close()
		_ = os.Remove(tmpName)
		return false, err
	}
	// sync & close tmp
	if err := tmp.Sync(); err != nil {
		log.Printf("warning: tmp file sync failed: %v\n", err)
	}
	if err := tmp.Close(); err != nil {
		_ = os.Remove(tmpName)
		return false, err
	}
	if !deleted {
		_ = os.Remove(tmpName)
		return false, nil
	}
	// atomic replace
	if err := os.Rename(tmpName, db.path); err != nil {
		_ = os.Remove(tmpName)
		return false, err
	}
	// open new file and fsync it to make rename durable
	if f, err := os.OpenFile(db.path, os.O_RDONLY, 0); err == nil {
		_ = f.Sync()
		_ = f.Close()
	}
	// fsync the directory to make rename durable
	if d, err := os.Open(dir); err == nil {
		_ = d.Sync()
		_ = d.Close()
	}
	return true, nil
}

func main() {
	// quick demo with concurrency
	randSeed := time.Now().UnixNano()
	_ = randSeed // not used except to avoid unused import if you reintroduce randomization
	dbPath := "demo.db"
	_ = os.Remove(dbPath) // start fresh for demo

	db, err := NewDB(dbPath, "|")
	if err != nil {
		panic(err)
	}

	var wg sync.WaitGroup

	// concurrent creators (they will be serialized by file lock, but this demonstrates correctness)
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			name := fmt.Sprintf("user|-%d", i) // contains delimiter to validate escaping
			email := fmt.Sprintf("user%d@example.com", i)
			rec, err := db.Create(name, email)
			if err != nil {
				fmt.Printf("create error: %v\n", err)
				return
			}
			fmt.Printf("created: %#v\n", rec)
		}(i)
	}

	// some readers
	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			time.Sleep(50 * time.Millisecond)
			recs, err := db.ReadAll()
			if err != nil {
				fmt.Printf("readall error: %v\n", err)
				return
			}
			fmt.Printf("read %d records\n", len(recs))
		}()
	}

	wg.Wait()

	// update id=3 (if exists)
	if updated, err := db.Update(3, "updated-name-3", "changed3@example.com"); err == nil {
		fmt.Println("updated:", updated)
	} else {
		fmt.Println("update failed:", err)
	}

	// delete id=2
	if ok, err := db.Delete(2); err != nil {
		fmt.Println("delete error:", err)
	} else if ok {
		fmt.Println("deleted id 2")
	} else {
		fmt.Println("id 2 not found")
	}

	// final dump
	all, _ := db.ReadAll()
	fmt.Println("final records:")
	for _, r := range all {
		fmt.Printf("%d: %s <%s>\n", r.ID, r.Name, r.Email)
	}
}
