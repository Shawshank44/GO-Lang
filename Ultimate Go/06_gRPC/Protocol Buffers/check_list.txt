Here‚Äôs the blunt truth: most developers screw up protobufs because they skip structure and jump straight to ‚Äúcompile and pray.‚Äù
You want an end-to-end checklist? Here‚Äôs the one that prevents 99% of mistakes. Follow this and you won‚Äôt ship broken proto files or generate garbage Go code.

---

# ‚úÖ **PROTOBUF END-TO-END CHECKLIST (For Your Exact File)**

## **1Ô∏è‚É£ File & Syntax Sanity**

* [ ] Confirm `syntax = "proto3";` (you already did).
* [ ] Ensure package name is versioned: **example.v1** ‚Üí good.
* [ ] Ensure file name matches the domain: `user.proto` (not mandatory but clean).

## **2Ô∏è‚É£ Go Package Setup (Most Devs Mess This Up)**

* [ ] `option go_package` must include:

  * Module path ‚Üí **github.com/you/project**
  * Directory ‚Üí **proto/example/v1**
  * Final Go package name ‚Üí **examplev1**
* [ ] Validate `go mod tidy` detects this module successfully.
* [ ] Make sure folder structure actually exists:

  ```
  project/
    proto/
      example/
        v1/
          user.proto
  ```

## **3Ô∏è‚É£ Imports**

* [ ] `google/protobuf/timestamp.proto` exists ‚Üí usually inside your system‚Äôs protobuf include path.
* [ ] Install/update google protos:

  ```
  go get google.golang.org/protobuf
  ```

## **4Ô∏è‚É£ Message Definitions**

### General Rules

* [ ] Field numbers are correct and **never reused** after deletion.
* [ ] Optional fields not needed in proto3 ‚Üí fine.
* [ ] No snake_case field names missed (proto standard).

### For Your `User` Message

* [ ] `int64 id = 1;` ‚Üí Good for primary keys.
* [ ] `google.protobuf.Timestamp created_at = 4;` ‚Üí Correct.
* [ ] `repeated string tags = 5;` ‚Üí OK.
* [ ] `map<string, int32> scores = 6;` ‚Üí OK.
* [ ] `oneof contact { phone = 7; mobile = 8; }` ‚Üí Confirm business logic ensures only one will be set.

## **5Ô∏è‚É£ Enum Checklist**

* [ ] First value is zero ‚Üí **STATUS_UNSPECIFIED = 0** ‚Üí correct.
* [ ] Names are PascalCase ‚Üí correct.
* [ ] No renamed enum values after release.

## **6Ô∏è‚É£ Request/Response Shapes**

* [ ] `GetUserRequest` contains only what the server needs.
* [ ] `GetUserResponse` wraps:

  * User ‚Üí object
  * Status ‚Üí enum (representing retrieval status or user state)

## **7Ô∏è‚É£ Service Definition**

* [ ] Service name is domain-specific: **UserService** ‚Üí good.
* [ ] Method signature:

  ```
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  ```

  ‚Üí proper unary gRPC.

## **8Ô∏è‚É£ Protogen Tools Installed (Don‚Äôt Skip This)**

Run these and confirm versions:

```
protoc --version
```

You MUST have:

```
google.golang.org/protobuf/cmd/protoc-gen-go
google.golang.org/grpc/cmd/protoc-gen-go-grpc
```

Install/update:

```
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
export PATH="$PATH:$(go env GOPATH)/bin"
```

## **9Ô∏è‚É£ Code Generation Command (Most People Screw This Up)**

From project root:

```
protoc \
  --proto_path=. \
  --go_out=. \
  --go-grpc_out=. \
  proto/example/v1/user.proto
```

Checklist:

* [ ] `--proto_path` points to root.
* [ ] Output directories exist.
* [ ] Code appears under:

  ```
  proto/example/v1/*.pb.go
  ```

## **üîü Validate Generated Code**

* [ ] Confirm the Go package name in generated files = **examplev1**
* [ ] Confirm generated structs appear:

  * `type User struct {}`
  * `type GetUserRequest struct {}`
  * `type GetUserResponse struct {}`
  * `type UserServiceClient interface { ... }`
* [ ] Confirm oneof wrapper types exist:

  * `*User_Phone`
  * `*User_Mobile`

## **1Ô∏è‚É£1Ô∏è‚É£ Implement the gRPC Server**

Skeleton you MUST have:

```go
type userServer struct {
    examplev1.UnimplementedUserServiceServer
}

func (s *userServer) GetUser(ctx context.Context, req *examplev1.GetUserRequest) (*examplev1.GetUserResponse, error) {
    return &examplev1.GetUserResponse{
        User: &examplev1.User{
            Id:    req.UserId,
            Name:  "Example",
            Email: "ex@example.com",
        },
        Status: examplev1.Status_ACTIVE,
    }, nil
}
```

Checklist:

* [ ] Struct embeds `UnimplementedUserServiceServer`.
* [ ] Request & response types match generated definitions.
* [ ] Timestamp generated with `timestamppb.New(time.Now())`.

## **1Ô∏è‚É£2Ô∏è‚É£ Register & Run Server**

```
grpcServer := grpc.NewServer()
examplev1.RegisterUserServiceServer(grpcServer, &userServer{})
```

Checklist:

* [ ] Register the service
* [ ] Start listening on a port
* [ ] TLS optional but recommended

## **1Ô∏è‚É£3Ô∏è‚É£ Client Call Test**

Use a Go client or evans / grpcurl.

Example:

```
grpcurl -plaintext localhost:50051 example.v1.UserService.GetUser \
   -d '{"user_id": 1}'
```

Checklist:

* [ ] Response includes user object
* [ ] Enum correctly returned
* [ ] oneof field is empty (expected unless you set it)

## **1Ô∏è‚É£4Ô∏è‚É£ Backward Compatibility Check**

Before releasing v1:

* [ ] No renaming / reordering fields
* [ ] No deleting fields
* [ ] No changing field types
* [ ] If removing, mark as deprecated instead

---

# Want me to generate:

‚úÖ A real folder structure
‚úÖ A Makefile for protogen
‚úÖ A ready-to-run server/client implementation
Just tell me.
